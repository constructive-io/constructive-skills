# Generated ORM Output Reference

Reference for Prisma-like ORM client generated by `@constructive-io/graphql-codegen generate-orm`.

## Output Structure

```
generated/orm/
├── index.ts      # Main export (createClient, types)
├── client.ts     # createClient() function
├── types.ts      # All TypeScript types
└── models/       # Entity model implementations
    ├── user.ts
    ├── post.ts
    └── ...
```

## Generated Files

### index.ts

Main export:

```typescript
export { createClient } from './client';
export * from './types';
```

### client.ts

Client factory:

```typescript
export function createClient(options: {
  endpoint: string;
  headers?: Record<string, string>;
  fetch?: typeof fetch;
}): DatabaseClient;
```

### types.ts

All TypeScript types including:

- Entity interfaces
- Select types with const generics
- Filter types
- Input types
- Result types with discriminated unions

## Client API

### Creating the Client

```typescript
import { createClient } from '@/generated/orm';

const db = createClient({
  endpoint: 'https://api.example.com/graphql',
  headers: {
    Authorization: `Bearer ${token}`,
  },
});
```

### Entity Models

Each table gets a model with these methods:

```typescript
db.user.findMany(options)   // List with filtering
db.user.findOne(options)    // Single item by ID
db.user.create(options)     // Create new
db.user.update(options)     // Update existing
db.user.delete(options)     // Delete
```

## Query Methods

### findMany

Fetch multiple items:

```typescript
const result = await db.user.findMany({
  select: {
    id: true,
    username: true,
    email: true,
  },
  filter: {
    role: { eq: 'ADMIN' },
  },
  orderBy: {
    createdAt: 'DESC',
  },
  first: 10,
  offset: 0,
}).execute();
```

#### Options

| Option | Type | Description |
|--------|------|-------------|
| `select` | SelectObject | Fields to return (type-narrowed) |
| `filter` | FilterObject | Where conditions |
| `orderBy` | OrderByObject | Sort order |
| `first` | number | Limit results |
| `last` | number | Last N results |
| `offset` | number | Skip N results |
| `before` | string | Cursor pagination |
| `after` | string | Cursor pagination |

### findOne

Fetch single item:

```typescript
const result = await db.user.findOne({
  id: '123',
  select: {
    id: true,
    username: true,
    posts: {
      select: { id: true, title: true },
    },
  },
}).execute();
```

## Mutation Methods

### create

Create new item:

```typescript
const result = await db.user.create({
  input: {
    username: 'john',
    email: 'john@example.com',
  },
  select: {
    id: true,
    username: true,
  },
}).execute();
```

### update

Update existing item:

```typescript
const result = await db.user.update({
  id: '123',
  patch: {
    username: 'jane',
  },
  select: {
    id: true,
    username: true,
  },
}).execute();
```

### delete

Delete item:

```typescript
const result = await db.user.delete({
  id: '123',
}).execute();
```

## Select and Type Inference

The ORM uses const generics for type-safe selects. Only selected fields appear in the return type:

```typescript
// Return type: { id: string; username: string }[]
const users = await db.user.findMany({
  select: { id: true, username: true },
}).execute().unwrap();

// Return type: { id: string; email: string; posts: { title: string }[] }[]
const usersWithPosts = await db.user.findMany({
  select: {
    id: true,
    email: true,
    posts: { select: { title: true } },
  },
}).execute().unwrap();
```

## Relations

### BelongsTo (Single Entity)

```typescript
const posts = await db.post.findMany({
  select: {
    id: true,
    title: true,
    author: {
      select: { id: true, name: true },
    },
  },
}).execute();

// posts[0].author.name is typed
```

### HasMany (Collection)

```typescript
const users = await db.user.findMany({
  select: {
    id: true,
    posts: {
      select: { id: true, title: true },
      filter: { published: { eq: true } },
      first: 5,
    },
  },
}).execute();

// users[0].posts is typed array
```

### ManyToMany

```typescript
const posts = await db.post.findMany({
  select: {
    id: true,
    tags: {
      select: { id: true, name: true },
    },
  },
}).execute();
```

### Deeply Nested

```typescript
const users = await db.user.findMany({
  select: {
    posts: {
      select: {
        comments: {
          select: {
            author: { select: { name: true } },
          },
        },
      },
    },
  },
}).execute();
```

## Filtering

### Comparison Operators

```typescript
filter: { age: { eq: 25 } }       // Equal
filter: { age: { neq: 25 } }      // Not equal
filter: { age: { gt: 18 } }       // Greater than
filter: { age: { gte: 18 } }      // Greater than or equal
filter: { age: { lt: 65 } }       // Less than
filter: { age: { lte: 65 } }      // Less than or equal
filter: { age: { in: [18, 21] } } // In array
filter: { age: { nin: [0, 1] } }  // Not in array
```

### String Operators

```typescript
filter: { name: { contains: 'john' } }
filter: { name: { startsWith: 'J' } }
filter: { name: { endsWith: 'son' } }
```

### Logical Operators

```typescript
// AND (implicit)
filter: {
  role: { eq: 'ADMIN' },
  active: { eq: true },
}

// AND (explicit)
filter: {
  AND: [
    { role: { eq: 'ADMIN' } },
    { createdAt: { gte: '2024-01-01' } },
  ],
}

// OR
filter: {
  OR: [
    { role: { eq: 'ADMIN' } },
    { role: { eq: 'MODERATOR' } },
  ],
}
```

## Error Handling

### Discriminated Union (Recommended)

```typescript
const result = await db.user.findOne({ id: '123' }).execute();

if (result.ok) {
  // result.value is typed
  console.log(result.value.username);
} else {
  // result.error contains error details
  console.error(result.error.message);
}
```

### Helper Methods

```typescript
// Throw on error
const user = await db.user.findOne({ id: '123' })
  .execute()
  .unwrap();

// Return default on error
const user = await db.user.findOne({ id: '123' })
  .execute()
  .unwrapOr({ id: '', username: 'Unknown' });

// Call function on error
const user = await db.user.findOne({ id: '123' })
  .execute()
  .unwrapOrElse((error) => {
    logger.error(error);
    return { id: '', username: 'Fallback' };
  });
```

### Error Types

```typescript
interface GraphQLError {
  type: 'graphql';
  message: string;
  locations?: { line: number; column: number }[];
  path?: string[];
}

interface NetworkError {
  type: 'network';
  message: string;
  status?: number;
}

interface ValidationError {
  type: 'validation';
  message: string;
  field?: string;
}
```

## Custom Operations

Custom queries and mutations from your schema are also available:

```typescript
// Custom query
const currentUser = await db.currentUser({
  select: { id: true, username: true },
}).execute();

// Custom mutation
const result = await db.login({
  email: 'user@example.com',
  password: 'secret',
}).execute();
```
